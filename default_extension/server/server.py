import keys

import ldclient
from ldclient import Context
from ldclient.config import Config as LDConfig
from threading import Lock, Event

from flask import Flask
from flask import after_this_request, jsonify, request

import boto3
from botocore.config import Config
import json
import logging

import base64
import io
import json
import logging
import boto3
from PIL import Image
import os
from io import BytesIO
import string

import random

from botocore.exceptions import ClientError

ld_sdk_key = keys.ls_sdk_key

feature_flag_key = "use-model"

ldclient.set_config(LDConfig(ld_sdk_key))
client = ldclient.get()

if not ldclient.get().is_initialized():
    print("*** SDK failed to initialize. Please check your internet connection and SDK credential for any typo.")
    exit()

print("*** SDK successfully initialized")

context = \
    Context.builder('example-user-key').kind('user').name('Tejas').build()

flag_value = ldclient.get().variation(feature_flag_key, context, False)

print(flag_value)

bedrock_config = Config(
    region_name = 'us-east-1',
    signature_version = 'v4',
    retries = {
        'max_attempts': 10,
        'mode': 'standard'
    }
)

brt = boto3.client(service_name='bedrock-runtime', config=bedrock_config, 
                   aws_access_key_id=keys.aws_access_key_id,
                   aws_secret_access_key=keys.aws_secret_access_key
                   )

accept = 'application/json'
contentType = 'application/json'


modelId = 'meta.llama3-8b-instruct-v1:0'
accept = 'application/json'
contentType = 'application/json'


# text
# print(response_body.get('generation'))

app = Flask(__name__)

app.config['IMG_PATH'] = 'gen_imgs'

@app.route("/")
def hello_world():
    context = \
        Context.builder('example-user-key').kind('user').name('Tejas').build()

    flag_value = ldclient.get().variation(feature_flag_key, context, False)
    show_evaluation_result(feature_flag_key, flag_value)

    change_listener = FlagValueChangeListener()
    listener = ldclient.get().flag_tracker \
        .add_flag_value_change_listener(feature_flag_key, context, change_listener.flag_value_change_listener)

    try:
        Event().wait()
    except KeyboardInterrupt:
        pass

    return "<p>Hello, World!</p>"


query = "hello"

@app.route("/generate", methods=['GET'])
def generate():
    @after_this_request
    def add_header(response):
        response.headers['Access-Control-Allow-Origin'] = '*'
        return response
    
    body = json.dumps({
        "prompt": "Given this context, give me relevant information: " 
                    + query,
        "max_gen_len": 30,
        "temperature": 0.1,
        "top_p": 0.9,
    })

    response = brt.invoke_model(body=body, modelId=modelId, accept=accept, contentType=contentType)

    response_body = json.loads(response.get('body').read())

    flag_value = ldclient.get().variation(feature_flag_key, context, False)
    print(flag_value)
    return jsonify(response_body)

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

class ImageError(Exception):
    "Custom exception for errors returned by SDXL"
    def __init__(self, message):
        self.message = message

def generate_image(model_id, body):
    """
    Generate an image using SDXL 1.0 on demand.
    Args:
        model_id (str): The model ID to use.
        body (str) : The request body to use.
    Returns:
        image_bytes (bytes): The image generated by the model.
    """

    logger.info("Generating image with SDXL model %s", model_id)

    bedrock = boto3.client(service_name='bedrock-runtime')
   
    accept = "application/json"
    content_type = "application/json"

    response = bedrock.invoke_model(
        body=body, modelId=model_id, accept=accept, contentType=content_type
    )
    response_body = json.loads(response.get("body").read())
    print(response_body['result'])

    base64_image = response_body.get("artifacts")[0].get("base64")
    base64_bytes = base64_image.encode('ascii')
    image_bytes = base64.b64decode(base64_bytes)

    finish_reason = response_body.get("artifacts")[0].get("finishReason")

    if finish_reason == 'ERROR' or finish_reason == 'CONTENT_FILTERED':
        raise ImageError(f"Image generation error. Error code is {finish_reason}")


    logger.info("Successfully generated image withvthe SDXL 1.0 model %s", model_id)

    return image_bytes

@app.route("/generateimg", methods=['GET'])
def generateimg():
    @after_this_request
    def add_header(response):
        response.headers['Access-Control-Allow-Origin'] = '*'
        return response
    
    model_id='stability.stable-diffusion-xl-v1'
    body=json.dumps({
        "text_prompts": [
        {
        "text": query
        }
    ],
    "cfg_scale": 10,
    "seed": random.randint(0, 2048),
    "steps": 50,
    "samples" : 1,
    "style_preset" : "photographic"

    })

    try:
        image_bytes=generate_image(model_id = model_id,
                                 body = body)
        
        #img_id = ''.join(random.choices(string.ascii_uppercase +
        #                     string.digits, k=8))
        
        #file_path = app.config['IMG_PATH'] + '/' + img_id + '.png'
        
        #with open(file_path, 'wb') as f:
        #    f.write(image_bytes)
        
        #image = Image.open(io.BytesIO(image_bytes))
        #image.show()


    except ClientError as err:
        message=err.response["Error"]["Message"]
        logger.error("A client error occurred: %s", message)
        print("A client error occured: " +
              format(message))
    except ImageError as err:
        logger.error(err.message)
        print(err.message)

    return image_bytes

@app.route("/guardian", methods=['GET', 'POST'])
def guardian(): 
    global query
    data = request.data.decode('utf-8')
    print(data)
    print(json.loads(data))
    data = json.loads(data)
    query = data['query']
    return jsonify({ "query": query })

visited_urls = []

@app.route("/embedding", methods=['POST'])
def embedding():
    data = request.data.decode('utf-8')
    print(data)
    print(json.loads(data))
    data = json.loads(data)
    url = data['url']
    visited_urls.append(url)
    return jsonify({ "url": url })
